<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer源码分析-共享式]]></title>
    <url>%2F2019%2F10%2F20%2FReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ReentrantLock是一个可重入且独占式的锁，该锁支持获取锁时的公平和非公平选择。 公平锁公平锁遵循FIFO的原则，所有的线程都会顺序执行 获取锁123456789101112 //加锁 final void lock() &#123; acquire(1); &#125;//调用AbstractQueuedSynchronizer public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt(); &#125; 是否是获得锁，还是进入队列等待的逻辑在tryAcquire 函数里。12345678910111213141516171819202122232425262728293031323334353637383940414243444546protected final boolean tryAcquire(int acquires) &#123; //获取当前线程 final Thread current = Thread.currentThread(); // 获取state值，state代表前线程获取锁的可重入次数 int c = getState(); /** 如果c为0，判断阻塞队列中是否还有线程， * 如果不存在，设置state的值，并设置当前线程为独占锁的拥有者 * 如果队列中还存在节点，则将该线程加入到队列中。 **/ if (c == 0) &#123; //判断队列中是否还存在线程 if (!hasQueuedPredecessors() &amp;&amp; //设置state值 compareAndSetState(0, acquires)) &#123; // 设置当前线程为独占锁的拥有者 setExclusiveOwnerThread(current); //返回ture代表获取锁成功 return true; &#125; &#125; /** * 如果c不为0，判断独占锁的拥有者是否是当前线程， * 如果是，则修改state值 **/ else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; /**返回 false 代表获取锁失败， * 则AbstractQueuedSynchronizer类的acquire函数继续往下进行，将该线程加入到队列中。 **/ return false;&#125;public final boolean hasQueuedPredecessors() &#123; Node t = tail; Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 释放锁1234567891011121314 public void unlock() &#123; sync.release(1); &#125;//调用AbstractQueuedSynchronizer public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; 具体的释放逻辑在release中，free代表该锁是否已完全释放锁，如果为true，AbstractQueuedSynchronizer继续执行release，唤醒队列中的下一个节点；false则该线程继续持有锁。1234567891011121314protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; //如果当前可重入次数为0 则清空锁持有线程 if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; 非公平锁非公平锁不会关注阻塞队列中是否还有线程，而是直接尝试获取锁，获取不到时在将线程加入到队列中。 获取锁12345678910111213final void lock() &#123; //修改state的值，修改成功则设值设置当前线程为独占锁的拥有者 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125; //调用AbstractQueuedSynchronizerpublic final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; 非公平锁与公平锁的差别在于当c为0时，不去查询队列的状态，而是直接尝试修改state的值12345678910111213141516171819202122protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 非公平锁和共平锁的释放锁逻辑相同。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer源码分析-共享式]]></title>
    <url>%2F2019%2F10%2F16%2FAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%85%B1%E4%BA%AB%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[共享式获得锁 共享式获取锁的顶层函数为acquireShared(),该函数首先调用tryAcquireShared()尝试互锁，如果获取不到锁，则将该线程加入到队列中。1234567public final void acquireShared(int arg) &#123; //尝试获取锁 //小于0，代表获取锁失败 // 具体的逻辑由子类实现 if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125; doAcquireShared()函数将该线程加入到队列中，然后通过有限次的循环获取锁，并判断是否该阻塞12345678910111213141516171819202122232425262728293031323334353637383940private void doAcquireShared(int arg) &#123; //将该线程加入到队列中 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取该线程节点的前趋节点。 final Node p = node.predecessor(); /** * 如果p为头节点，再次尝试获取锁 * p可能是独占式节点（EXCLUSIVE），也可能是共享式节点（SHARED）. * 独占式节点则不能再获取锁 * 共享式节点可以获取锁，但当资源用尽时也不能获取到锁 * 能不能获取到锁，要看具体tryAcquireShared的实现 **/ if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; //设置头节点和唤醒下一个共享线程 setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) //如果阻塞过程中，有过中断，先不处理，再获取到资源后，再处理中断。 selfInterrupt(); failed = false; return; &#125; &#125; // 判断是否应该阻塞，如果要阻塞则将线程阻塞，并判断是否有过中断 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 1234567891011121314private void setHeadAndPropagate(Node node, int propagate) &#123; //获取头节点 Node h = head; //将当前节点设置成头节点 setHead(node); if (propagate &gt; 0 || h == null || h.waitStatus &lt; 0 || (h = head) == null || h.waitStatus &lt; 0) &#123; Node s = node.next; //如果s是共享节点，则唤醒共享节点 if (s == null || s.isShared()) doReleaseShared(); &#125;&#125; 123456789101112131415161718192021222324private void doReleaseShared() &#123; /* * 下面的循环在 head 节点存在后继节点的情况下，做了两件事情： * 1. 如果 head 节点等待状态为 SIGNAL，则将 head 节点状态设为 0，并唤醒后继节点 * 2. 如果 head 节点等待状态为 0，则将 head 节点状态设为 PROPAGATE，保证唤醒能够正 * 常传播下去。关于 PROPAGATE 状态的细节分析，后面会讲到。 */ for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125; &#125; 共享式释放锁1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AbstractQueuedSynchronizer源码分析-独占式]]></title>
    <url>%2F2019%2F10%2F13%2FAbstractQueuedSynchronizer%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E7%8B%AC%E5%8D%A0%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[独占式获得锁 独占式下的顶层函数为acquire(),首先调用tryAcquire()函数获得锁，如果获取不到锁，则将线程加入到队列中。 1234567public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; //尝试获得锁 //将线程加入到对列中，循环获取资源，并在一定次数后阻塞 acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //在阻塞过程中线程可能被中断，忽略中断，在获取到锁后再进行中断。 selfInterrupt();&#125; addWaiter()将线程加入到阻塞队列中。12345678910111213141516private Node addWaiter(Node mode) &#123; //将建一个队列节点，并设置该节点为独占模式 Node node = new Node(Thread.currentThread(), mode); // 尝试快速插入到队列中，失败则调用enq函数 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125; 将node节点放入到对尾中。12345678910111213141516171819private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; //如果队列为空，则设置对尾节点为空，并将队首指向对尾 if (t == null) &#123; if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //将该节点的前趋节点设置为当前对列尾节点 node.prev = t; //将对尾节点设置为尾节点 if (compareAndSetTail(t, node)) &#123; //将原尾节点的后继指向该节点 t.next = node; return t; &#125; &#125; &#125;&#125; acquireQueued()通过自旋的方式获取同步状态，在需要阻塞线程的时候阻塞线程。1234567891011121314151617181920212223242526final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取当前节点的前趋节点 final Node p = node.predecessor(); //判断前趋节点是否是头节点，如果是，再次掉用tryAcquire尝试获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //如果获取到锁，则将当前节点设置成头节点 setHead(node); //在设置头节点时，node的前趋节点已经设置成null，所以这里只将p的next设置成null，p节点将不在队列中 p.next = null; // help GC failed = false; return interrupted; &#125; //判断是否应该被阻塞，如果应该被阻塞则阻塞该节点 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 判断是否应该挂起该线程1234567891011121314151617private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) //如果当前节点的前趋节点的状态为SIGNAL则阻塞当前节点 return true; if (ws &gt; 0) &#123; do &#123; //如果当前节点的前趋节点状态&gt;0(CANCELLED),那就一直往前找 node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; //如果前趋节点为正常状态，则修改前趋节点的状态为SIGNAL，用于线程结束时，唤起下一个节点 compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125; 挂起线程123456private final boolean parkAndCheckInterrupt() &#123; //阻塞当前线程 LockSupport.park(this); //当前线程可被中断，返回该线程的中断状态，在该线程获取到锁后，再进行中断 return Thread.interrupted();&#125; 独占式释放锁12345678910public final boolean release(int arg) &#123;//尝试获释放锁 if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125; 1234567891011121314151617181920private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; //修改头节点的状态 if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); //获取头节点的下一个节点 Node s = node.next; //判断s线程是否是null，或线程状态是否是&gt;0(比如CANCELLED状态 代表取消），如果为true，则遍历队列，找到应该被唤醒的线程。 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) //唤醒线程 LockSupport.unpark(s.thread); &#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[elementUI显示标签页功能]]></title>
    <url>%2F2019%2F09%2F13%2FelementUI%E6%98%BE%E7%A4%BA%E6%A0%87%E7%AD%BE%E9%A1%B5%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[思路： 1、在vuex中存储点击过的标签页 2、当路由刷新时，将路由添加到vuex中，并判断当前路由是否已经再标签页列表中 3、关闭标签页时，将vuex中的路由删除代码：vuex中保存点击过的路由列表，新建tagsPages.js文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354const tagsPages= &#123; state:&#123; //路由列表 tagsPages:[] &#125;, mutations:&#123; //添加路由 ADD_PAGE(state,page)&#123; //判断路由是否已经在列表中，如果存在，不再添加到列表中 if(state.tagsPages.some(item=&gt;item.path == page.path)) return; //添加路由到列表中 state.tagsPages.push(&#123; name: page.name, title: page.meta.title, path: page.path &#125;) &#125;, //删除路由 DEL_PAGE(state,page)&#123; for(let[i,p] of state.tagsPages.entries())&#123; if(p.path == page.path)&#123; state.tagsPages.splice(i,1) break &#125; &#125; &#125; &#125;, actions:&#123; //添加路由 addPage(&#123;commit&#125;,page)&#123; commit("ADD_PAGE",page) &#125;, //删除路由 delPage(&#123;commit, state &#125;,page)&#123; return new Promise((resolve) =&gt; &#123; commit("DEL_PAGE",page) resolve([...state.tagsPages]) &#125;) &#125; &#125;&#125;export default tagsPages 添加到vuex中12345678910111213import Vue from 'vue'import Vuex from 'vuex'import tagsPages from './tagsPages'Vue.use(Vuex)const store= new Vuex.Store(&#123; modules:&#123; tagsPages &#125;&#125;)export default store 标签页组件tagsPage.vue,没有写css样式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;template&gt; &lt;div&gt; &lt;el-scrollbar ref="scrollContainer" :vertical="false" &gt; &lt;router-link v-for="tag in tagsPages" ref="tag" :to="&#123; path: tag.path&#125;" :key="tag.path" tag="span" &gt; &lt;span class="el-icon-close" @click.prevent.stop="closeSelectedTag(tag)" /&gt; &#123;&#123; tag.title &#125;&#125; &lt;/router-link&gt; &lt;/el-scrollbar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; left: 0 &#125;; &#125;, computed: &#123; tagsPages() &#123; //从store中获取点击过的路由列表 return this.$store.state.tagsPages.tagsPages ; &#125; &#125;, watch: &#123; //当路由改变时，添加路由到路由列表 $route() &#123; this.addTagsPage(); &#125; &#125;, methods: &#123; addTagsPage() &#123; //路由改变时执行的方法 if (this.$route.name) &#123; const route = this.$route; this.$store.dispatch("addPage", route); &#125; &#125;, //关闭标签页 closeSelectedTag(view) &#123; this.$store.dispatch("delPage", view).then(visitedViews =&gt; &#123; //判断关闭的标签页是不是当前页 //如果是当前页，则判断路由列表中是否还存在路由 //如果存在则跳转到到最后打开的页面 //如果不存在则跳转到首页 if (view.path == this.$route.path) &#123; const latestView = visitedViews.slice(-1)[0]; if (latestView) &#123; this.$router.push(latestView); &#125; else &#123; this.$router.push("/"); &#125; &#125; &#125;); &#125; &#125;&#125;;&lt;/script&gt;]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存模型]]></title>
    <url>%2F2018%2F09%2F02%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JVM内存模型Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： 程序计数器 Java虚拟机栈 本地方法栈 堆 方法区。 下面对这五个区域展开深入的介绍。 1. 程序计数器1.1. 什么是程序计数器？程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。注：但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。 1.2. 程序计数器的作用程序计数器有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 1.3. 程序计数器的特点 是一块较小的存储空间 线程私有。每条线程都有一个程序计数器。 是唯一一个不会出现OutOfMemoryError的内存区域。 生命周期随着线程的创建而创建，随着线程的结束而死亡。 2. Java虚拟机栈(JVM Stack)2.1. 什么是Java虚拟机栈？Java虚拟机栈是描述Java方法运行过程的内存模型。Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括： 局部变量表 存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。 操作数栈 动态链接 方法出口信息等 当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。 注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。 2.2. Java虚拟机栈的特点局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。而且，局部变量表的大小在编译时期就确定下来了，在创建的时候只需分配事先规定好的大小即可。此外，在方法运行的过程中局部变量表的大小是不会发生改变的。Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。a) StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。b) OutOfMemoryError： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。注：StackOverFlowError和OutOfMemoryError的异同？StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 3. 本地方法栈3.1. 什么是本地方法栈？本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。方法执行完毕后相应的栈帧也会出栈并释放内存空间。也会抛出StackOverFlowError和OutOfMemoryError异常。 4. 堆4.1. 什么是堆？堆是用来存放对象的内存空间。几乎所有的对象都存储在堆中。 4.2. 堆的特点 线程共享 整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的。 在虚拟机启动时创建 垃圾回收的主要场所。 可以进一步细分为：新生代、老年代。 新生代又可被分为：Eden、From Survior、To Survior。 不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。 堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。 5. 方法区5.1. 什么是方法区？Java虚拟机规范中定义方法区是堆的一个逻辑部分。方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。 5.2. 方法区的特点 线程共享 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。 永久代 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。 内存回收效率低 方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。 Java虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 5.3. 什么是运行时常量池？方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。我们一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。当这个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：String类的intern()方法就能在运行期间向常量池中添加字符串常量。当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。 6. 直接内存直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM异常。综上所述 1、Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。 2、两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 3、只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。 4、Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。 5、堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。 6、程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。 7、而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。 转载自：https://blog.csdn.net/u010425776/article/details/51170118]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList扩容机制]]></title>
    <url>%2F2018%2F08%2F04%2FArrayList%E6%89%A9%E5%AE%B9%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[首先看一下ArrayList的构造函数，ArrayList有3个构造函数。12345678910111213141516171819202122232425262728293031323334private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;//用于默认大小的空实例的共享空数组实例。将其与空的元素data区分开来，以知道在添加第一个元素时要填充多少。private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;public ArrayList() &#123; //设置数组没空 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; //创建initialCapacity大小的数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; //初始容量为0,则设置为空数组 this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 在已无参的构造函数创建ArrayList时，初始化的是一个空数组，并没有设置数组的大小，只有当第一次添加的时候，才分配数组大小。当调用add()函数时的逻辑。1234567public boolean add(E e) &#123; //添加之前先判断是否需要扩容 ensureCapacityInternal(size + 1); // Increments modCount!! //添加元素 elementData[size++] = e; return true; &#125; 扩容的具体逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));&#125;private static final int DEFAULT_CAPACITY = 10;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; //判断是否是默认的空数组 if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 获取默认的容量和传入参数的较大值 return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 判断传入的获取到的数组长度是否大于当前数组的长度，如果大于则扩容 // 当第一次添加时，数组默认值为0,这时才设置数组大小 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125;//要分配的数组的最大大小。//一些vm在数组中保留一些头字。尝试分配较大的数组可能会导致OutOfMemory错误：请求的数组大小超过了VM限制private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;private void grow(int minCapacity) &#123; int oldCapacity = elementData.length; //扩容的长度为原来数组的长度加原来数组长度的一半，也就是1.5杯倍 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; //如果扩容的长度大于最大长度，则重新计算应该扩容的长度 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 扩容 elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) throw new OutOfMemoryError(); //如果添加后的长度大于默认最大长度，则设置成Integer.MAX_VALUE;否则，设置成默认最大长度 return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java SpringBoot上的参数校验JSR 303 Validation]]></title>
    <url>%2F2018%2F06%2F26%2Fvalidation%2F</url>
    <content type="text"><![CDATA[JSR 303 – Bean Validation 是一个数据验证的规范，2009 年 11 月确定最终方案。Hibernate Validator 是 Bean Validation 的参考实现 . Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint我们通常写接口时会对传来的参数进行校验判断，比如字符串非空判断，值在多少返回等,这些就要用到Spring 的参数校验，这里我们使用在spring-boot-starter-web包里面有hibernate-validator包，参数校验有几种方式，如下 使用@Valid+BindingResult 注解使用@Valid +全局异常捕捉处理 使用@Valid+BindingResult 参数验证1.符合国际JSP 303规范，先定义个Bean，别人在字段名上添加验证的注解，@NotBlank 字段名不能为null，同时长度大于0常有的校验类型有123456789101112131415Constraint 详细信息@Null 被注释的元素必须为 null@NotNull 被注释的元素必须不为 null@AssertTrue 被注释的元素必须为 true@AssertFalse 被注释的元素必须为 false@Min(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@Max(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@DecimalMin(value) 被注释的元素必须是一个数字，其值必须大于等于指定的最小值@DecimalMax(value) 被注释的元素必须是一个数字，其值必须小于等于指定的最大值@Size(max, min) 被注释的元素的大小必须在指定的范围内@Digits (integer, fraction) 被注释的元素必须是一个数字，其值必须在可接受的范围内@Past 被注释的元素必须是一个过去的日期@Future 被注释的元素必须是一个将来的日期@Pattern(value) 被注释的元素必须符合指定的正则表达式 12345678910111213141516171819202122232425public class User &#123; //账号 @NotBlank(message = "账号不能为空") private String phone; //密码 @NotBlank(message = "密码不能为空") private String password; public void setPhone(String phone) &#123; this.phone = phone; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getPhone() &#123; return phone; &#125; public String getPassword() &#123; return password; &#125;&#125; 2.在Controller类里面对相应的接口添加@Valid+BindingResult验证，加完以后，如果参数验证不通过，那就直接进入if语句里面，在语句里面做相应的返回结果1234567891011121314151617@RestController@RequestMapping(value = "/user")public class UserController implements IUser &#123; @Override @RequestMapping(value = "/login", method = RequestMethod.POST) public User login( @Valid User userInfo, BindingResult bindingResult) &#123; if (bindingResult.hasErrors()) &#123; System.out.print(bindingResult.getFieldError().getDefaultMessage()); return null; &#125; return userInfo; &#125;&#125; 好了，第一种验证我们已经说完了，但你仔细想想，如果我有多个接口，是不是每次有要写@Valid+BindgResult bingingResult,然后再到If语句里面进行判断，如果仅仅是错误信息不一致，但返回的客户端结构是一致的，比如12&#123;&quot;code&quot;:&quot;1002&quot;,&quot;message&quot;:&quot;parameters are missing&quot;,&quot;data&quot;:&quot;&#123;&#125;&quot;&#125; 不同的验证只要改变message,那么是不是可以统一处理，来减少代码量，于是下面介绍第二种方式 使用@Valid+全局异常捕捉 参数校验简单点说，由第一种方式去掉BindingResult，然后再定义一个全局异常类，同样的1.还是定义POJO12345678910111213141516171819202122232425public class User &#123; //账号 @NotBlank(message = "账号不能为空") private String phone; //密码 @NotBlank(message = "密码不能为空") private String password; public void setPhone(String phone) &#123; this.phone = phone; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getPhone() &#123; return phone; &#125; public String getPassword() &#123; return password; &#125;&#125; 2.在Controller里面的方法定义要验证的@Valid123456789public class UserController implements IUser &#123; @Override @RequestMapping(value = "/login2", method = RequestMethod.POST) public User login2(@RequestBody @Valid User userInfo) &#123; return null; &#125; &#125; 3.定义全局异常类所有验证失败的结果都会在GlobleExceptionHandler的defultExcepitonHandler方法里面捕捉到12345678910111213141516171819202122232425262728@RestControllerAdvice@Componentpublic class GlobleExceptionHandler &#123; @ResponseBody @ExceptionHandler(Exception.class) public String defultExcepitonHandler(Exception ex) &#123; ex.printStackTrace(); if(ex instanceof BindException)&#123; //处理返回的错误信息 StringBuffer errorMsg = new StringBuffer(); BindException c = (BindException) ex; List&lt;ObjectError&gt; errors = c.getBindingResult().getAllErrors(); for (ObjectError error : errors) &#123; errorMsg.append(error.getDefaultMessage()).append(";"); &#125; return errorMsg.toString(); &#125; return ""; &#125;&#125; 作者：飞一样的猪链接：https://juejin.im/post/5b2f4514f265da597a6108f8来源：掘金]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springboot使用freemarker发送模板邮件]]></title>
    <url>%2F2018%2F06%2F25%2Fspringboot-mail-freemarker%2F</url>
    <content type="text"><![CDATA[springboot使用freemarker发送模板邮件1、引入mail和freemarker模块依赖12345678&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 2、在配置文件中配置信息12345678spring: mail: default-encoding: utf-8 host: smtp.126.com password: xxxxxxx port: 25 protocol: smtp username: xxxxx@126.com 3、在resources/templates下新建模板welcome.ftl123456&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;h4&gt;$&#123;UserName&#125;，你好！&lt;/h4&gt; &lt;/body&gt; &lt;/html&gt; 4、使用模板测试12345678910111213141516171819202122232425262728293031323334@Autowired private Configuration configuration;@Autowired private JavaMailSender jms;@Test public void send()&#123; MimeMessage message =jms.createMimeMessage(); try &#123; MimeMessageHelper helper = new MimeMessageHelper( message,true); helper.setFrom("xxxx@126.com"); helper.setTo("xxxx@qq.com"); helper.setSubject("使用模板"); Map&lt;String, Object&gt; model = new HashMap(); model.put("UserName", "yao"); try &#123; Template template = configuration.getTemplate("welcome.ftl"); String html = FreeMarkerTemplateUtils.processTemplateIntoString(template,model); helper.setText(html,true); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; catch (MessagingException e) &#123; e.printStackTrace(); &#125; jms.send(message);&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04下源码安装go1.10.1编译器]]></title>
    <url>%2F2018%2F04%2F12%2Fgo%2F</url>
    <content type="text"><![CDATA[Ubuntu下直接安装go1.10.1版本的go语言编译器需要依赖go1.4版本。所以在安装1.4版本以上的时候，需要安装1.4版本。 设置环境变量1sudo vim /etc/profile 在结尾处添加123export GOROOT=$HOME/goexport PATH=$PATH:$GOROOT/binexport GOPATH=$HOME/Applications/Go 使配置文件生效1source /etc/profile 安装C 工具1sudo apt-get install bison ed gawk gcc libc6-dev make 安装1.4下载地址 https://golang.org/dl/(需要翻墙)如果需要安装1.4以上的版本，需要把1.4版本一起下载。1tar -zxvf go1.4.linux-amd64.tar.gz 将文件移到/home/xxx,xxx为计算机名，并将文件名改为go1.4。如果已经在该目录下，则只把文件名改为go1.4即可。1mv go /home/xxx/go1.4 安装1.4编译器12cd go1.4/src/sudo CGO_ENABLED=0 ./make.bash 安装1.10.1解压1.10.1版本12tar -zxvf go1.10.linux-amd64.tar.gzmv go /home/xxx # xxx为计算机名 安装1.10.1 12cd /home/xxx/go/src./all.bash 安装成功如下图所示 测试在完成安装后可输入go env，如果显示类似以下内容，则表示成功1234567891011121314151617181920212223GOARCH=&quot;amd64&quot;GOBIN=&quot;&quot;GOCACHE=&quot;/home/yao/.cache/go-build&quot;GOEXE=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;linux&quot;GOOS=&quot;linux&quot;GOPATH=&quot;/home/yao/Applications/Go&quot;GORACE=&quot;&quot;GOROOT=&quot;/home/yao/go&quot;GOTMPDIR=&quot;&quot;GOTOOLDIR=&quot;/home/yao/go/pkg/tool/linux_amd64&quot;GCCGO=&quot;gccgo&quot;CC=&quot;gcc&quot;CXX=&quot;g++&quot;CGO_ENABLED=&quot;1&quot;CGO_CFLAGS=&quot;-g -O2&quot;CGO_CPPFLAGS=&quot;&quot;CGO_CXXFLAGS=&quot;-g -O2&quot;CGO_FFLAGS=&quot;-g -O2&quot;CGO_LDFLAGS=&quot;-g -O2&quot;PKG_CONFIG=&quot;pkg-config&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build612857100=/tmp/go-build -gno-record-gcc-switches&quot; 如果没有，也可能是环境变量没有生效，重启一下电脑试试 代码测试新建一个hello.go文件，输入以下内容12345package mainfunc main() &#123; println("Hello", "world")&#125; 运行1go run hello.go 会输出Hello world]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[登录校园网脚本]]></title>
    <url>%2F2018%2F03%2F30%2FloginSchool%2F</url>
    <content type="text"><![CDATA[前段时间浏览器出问题了，等不上校网，分析了一下校网登录过程，写了一个登录脚本。首先分析一下登录信息，主要的内容如下图：登录的链接为1http://1.1.1.1:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=1.1.1.1&amp;iTermType=1&amp;wlanuserip=10.133.82.103&amp;wlanacip=null&amp;wlanacname=null&amp;mac=00-00-00-00-00-00&amp;ip=10.133.82.103&amp;enAdvert=0&amp;queryACIP=0&amp;loginMethod=1 其中wlanuserip和ip是相同的，这个是连上校网之后的分配的ip，查看自己的网络信息就能看到。其余的为默认值表单里的数据12345678910111213141516DDDDD: ,0,201508030329@cmccupass: 190834R1: 0R2: 0R3: 0R6: 0para: 000MKKey: 123456buttonClicked: redirect_url: err_flag: username: password: user: cmd: Login: DDDD为帐号拼接起来的信息，其中@后边的信息为运营商的信息。移动的为cmcc、联通的为unicom、电信的为telecom、校园单宽为founder 校园内网为free。upass为密码，其余的都是默认值。请求头里的cookie值1234567program=NEW; vlan=0; ip=10.133.82.103; ssid=null; areaID=null; ISP_select=@cmcc; md5_login2=%2C0%2C201508030329@cmcc%7C190834 其中主要为ip、ISP_select、md5_login2，其余的都是默认值。 ip和链接上的ip相同 ISP_select为运营商 md5_login2中%2C0%2C为固定值，紧接帐号、运营商、%7C为固定值、密码。 脚本代码：123456789101112131415161718192021222324# -*- coding: utf-8 -*-import urllib import urllib2 url = 'http://1.1.1.1:801/eportal/?c=ACSetting&amp;a=Login&amp;protocol=http:&amp;hostname=1.1.1.1&amp;iTermType=1&amp;wlanuserip=10.133.82.103&amp;wlanacip=null&amp;mac=00-00-00-00-00-00&amp;ip=10.133.82.103&amp;enAdvert=0&amp;queryACIP=0&amp;loginMethod=1'user_agent = 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/66.0.3359.139 Safari/537.36' values = &#123; 'DDDDD' : ',0,201508030329@cmcc', 'upass' : '190834', 'R1':'0', 'R2':'0', 'R3':'0', 'R6':'0', 'para':'00', '0MKKey':'123456' &#125; headers = &#123; 'User-Agent' : user_agent, 'Cookie':'program=NEW; vlan=0; ip=10.133.82.103; ssid=null; areaID=null; ISP_select=@cmcc; md5_login2=%2C0%2C201508030329@cmcc%7C190834' &#125; data = urllib.urlencode(values) request = urllib2.Request(url, data ,headers) response = urllib2.urlopen(request) page = response.read()print page]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SpringBoot多模块项目]]></title>
    <url>%2F2018%2F03%2F25%2FSpringBootModule%2F</url>
    <content type="text"><![CDATA[今天搭建SpringBoot多模块项目，总是出现Unregistering JMX-exposed beans on shutdown，找了半天，才发现是jar包问题。 总结一下搭建SpringBoot多模块项目的步骤： 搭建项目架构1、创建一个maven空项目，并删掉src文件，如下图： 2、新建一个module，如下图 3、选择空maven项目，点击next，输入模块名，如下图： 4、一直默认下去，最后项目架构类似下图： 5、其他模块创建类似 配置文件1、在父工程的pom中配置如下： 12345678910111213141516171819202122232425 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--基本信息--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--项目信息--&gt; &lt;groupId&gt;com.yao&lt;/groupId&gt; &lt;artifactId&gt;BootModule&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--模块信息--&gt; &lt;modules&gt; &lt;module&gt;module_web&lt;/module&gt; &lt;/modules&gt; &lt;!--SpringBoot 的继承信息--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt;&lt;/project&gt; 2、在moduel_web的pom文件配置123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--继承的醒目说明--&gt; &lt;parent&gt; &lt;artifactId&gt;BootModule&lt;/artifactId&gt; &lt;groupId&gt;com.yao&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!--项目说明--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;module_web&lt;/artifactId&gt; &lt;!--具体相关的依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.yao&lt;/groupId&gt; &lt;artifactId&gt;module_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、创建启动类和application.yml配置文件，结构如下图所示： 4、编写启动类123456789import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpirngMain &#123; public static void main(String[] args) &#123; SpringApplication.run(SpirngMain.class,args); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot使用拦截器]]></title>
    <url>%2F2018%2F03%2F24%2FspingbootInteceptor%2F</url>
    <content type="text"><![CDATA[在springboot web开发中经常需要拦截器，创建拦截器的步骤： 实现HandlerInterceptor接口，重写接口中的三个方法：12345678910111213141516171819202122232425262728293031import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class InterceptorConfig implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(InterceptorConfig.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.info("-------&gt;在controller执行之前执行&lt;-------"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.info("-------&gt;在controller执行之后，页面渲染之前执行&lt;-------"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.info("-------&gt;页面渲染之后，多用于资源清理操作&lt;-------"); &#125;&#125; 注册拦截器 12345678910import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;public class WebAppConfig extends WebMvcConfigurerAdapter &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new InterceptorConfig()).addPathPatterns("/*"); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MKL]]></title>
    <url>%2F2018%2F03%2F14%2FMKL%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04安装MKL：下载 https://software.intel.com/en-us/mkl 解压进入解压文件，执行：1./install.sh 在 /etc/ld.so.conf.d 下创建名为 intel-mkl.conf 的文件，内容为12/opt/intel/mkl/lib/intel64 /opt/intel/lib/intel64 执行123ldconfig -v /opt/intel/mkl/bin/mklvars.sh intel64 ilp64 编译：以编译官方文档上的 dgemm_example.c 为例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#define min(x,y) (((x) &lt; (y)) ? (x) : (y)) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "mkl.h" int main() &#123; double *A, *B, *C; int m, n, p, i, j; double alpha, beta; printf ("\n This example computes real matrix C=alpha*A*B+beta*C using \n" " Intel(R) MKL function dgemm, where A, B, and C are matrices and \n" " alpha and beta are double precision scalars\n\n"); m = 2000, p = 200, n = 1000; printf (" Initializing data for matrix multiplication C=A*B for matrix \n" " A(%ix%i) and matrix B(%ix%i)\n\n", m, p, p, n); alpha = 1.0; beta = 0.0; printf (" Allocating memory for matrices aligned on 64-byte boundary for better \n" " performance \n\n"); A = (double *)mkl_malloc( m*p*sizeof( double ), 64 ); B = (double *)mkl_malloc( p*n*sizeof( double ), 64 ); C = (double *)mkl_malloc( m*n*sizeof( double ), 64 ); if (A == NULL || B == NULL || C == NULL) &#123; printf( "\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"); mkl_free(A); mkl_free(B); mkl_free(C); return 1; &#125; printf (" Intializing matrix data \n\n"); for (i = 0; i &lt; (m*p); i++) &#123; A[i] = (double)(i+1); &#125; for (i = 0; i &lt; (p*n); i++) &#123; B[i] = (double)(-i-1); &#125; for (i = 0; i &lt; (m*n); i++) &#123; C[i] = 0.0; &#125; printf (" Computing matrix product using Intel(R) MKL dgemm function via CBLAS interface \n\n"); cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, m, n, p, alpha, A, p, B, n, beta, C, n); printf ("\n Computations completed.\n\n"); printf (" Top left corner of matrix A: \n"); for (i=0; i&lt;min(m,6); i++) &#123; for (j=0; j&lt;min(p,6); j++) &#123; printf ("%12.0f", A[j+i*p]); &#125; printf ("\n"); &#125; printf ("\n Top left corner of matrix B: \n"); for (i=0; i&lt;min(p,6); i++) &#123; for (j=0; j&lt;min(n,6); j++) &#123; printf ("%12.0f", B[j+i*n]); &#125; printf ("\n"); &#125; printf ("\n Top left corner of matrix C: \n"); for (i=0; i&lt;min(m,6); i++) &#123; for (j=0; j&lt;min(n,6); j++) &#123; printf ("%12.5G", C[j+i*n]); &#125; printf ("\n"); &#125; printf ("\n Deallocating memory \n\n"); mkl_free(A); mkl_free(B); mkl_free(C); printf (" Example completed. \n\n"); return 0; &#125; 执行123. /opt/intel/bin/compilervars.sh intel64gcc dgemm_example.c -lmkl_rt]]></content>
  </entry>
  <entry>
    <title><![CDATA[Springboot中AOP的使用]]></title>
    <url>%2F2018%2F03%2F14%2FSpringboot-AOP%2F</url>
    <content type="text"><![CDATA[AOP是spring的两个主要模块功能之一，总结一下aop的基本用法 切面类组成首先需要在类中用@Aspect，说明这个类时切面类，这个类主要由两个部分组成：@Pointcut和Advice @Pointcut@Pointcut是一个注解，标注在类中的方法上，主要的作用是说明要处理那些类和那些方法。 @Pointcut 里的参数式一个表达式，包括指示器、通配符和运算符。 指示器按功能主要包括5类： 匹配方法：execution() 匹配注解：@target() @arges() @within() @annotation() 匹配包或类型：within() 匹配对象：this() bean() target() 匹配参数：arges() 注意！！ 只有匹配注解的前边有@符号 通配符主要包含3种： *：任意数量的字符 +：指定类及其子类 ..：任意数的子包或参数 运算符也主要包括3种： &amp;&amp;：与 ||：或 ！：非 AdviceAdvice说明了要执行的时机，主要是标注的类的方法上。 Advice主要有5种注解： @Before：前置通知 @After： 后置通知，方法执行完之后 @AfterReturning： 返回通知，成功执行之后 @AfterThrowing：异常通知，抛出异常之后 @Around：环绕通知 用法@Pointcut用法 在@Pointcut中execution()的应用最广，所以主要以execution()为例说明@Pointcut的用法 execution()的语法为： execution(方法修饰符(可选) 返回类型 方法名 参数 异常模式(可选)) 12@Pointcut("execution(public * com.example.aopdemo.Controller.*.*(..))")public void excudeService()&#123;&#125; 这个java代码中： 第一个* 号说明返回值为任意类型 第二个*号说明是任意类 第三个* 号说明的是任意方法 .. 说明参数为任意个所以整个 @Pointcut说明处理的是com.example.aopdemo.Controller包下所有的类以及类中所有的方法，方法参数不限的方法。 Advice用法 Advice的用法大同小异，主要的差别是执行的时机，所以，主要以@Before为例说明用法 12345678@Before("excudeService()")public void before(JoinPoint joinPoint)&#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method=methodSignature.getMethod(); logger.info("-----------"+method.getName()); logger.info("---------before---------");&#125; 这个before方法说明在excudeService()这个@Pointcut处理的范围之内，所有方法运行之前先运行before函数。 完整Aspect类例子的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.lang.reflect.Method;@Aspect@Componentpublic class AopConfig &#123; Logger logger = LoggerFactory.getLogger(AopConfig.class); @Pointcut("execution(public * com.example.aopdemo.Controller.*.*(..))") public void excudeService()&#123;&#125; @Pointcut("execution(* *..find*(String)) &amp;&amp; within(com.example..*) ") public void matchLongArg()&#123;&#125; @Before("excudeService()") public void before(JoinPoint joinPoint)&#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method=methodSignature.getMethod(); logger.info("-----------"+method.getName()); logger.info("---------before---------"); &#125; @After("excudeService()") public void after(JoinPoint joinPoint)&#123; Object [] args = joinPoint.getArgs(); for (int i = 0; i &lt; args.length; i++) &#123; logger.info(String.valueOf(args[i])); &#125; logger.info("---------after---------"); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装openBLAS]]></title>
    <url>%2F2018%2F03%2F13%2Finstall-openBLAS%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04 安装OpenBLAS步骤 12345git clone git://github.com/xianyi/OpenBLAScd OpenBLASsudo apt-get install gfortransudo make FC=gfortransudo make install 最后安装在/opt下 然后执行以下命令：1ln -s /opt/OpenBLAS/lib/libopenblas.so.0 /usr/lib/libopenblas.so.0 建立一个c.c文件，输入以下内容123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "cblas.h"int main()&#123; int n; /*! array size */ double da; /*! double constant */ double *dx; /*! input double array */ int incx; /*! input stride */ double *dy; /*! output double array */ int incy; /*! output stride */ int i; n = 10; da = 10; dx = (double*)malloc(sizeof(double)*n); incx = 1; dy = (double*)malloc(sizeof(double)*n); incy = 1; for(i=0;i&lt;n;i++)&#123; dx[i] = 9-i; dy[i] = i; printf("%f ",dy[i]); //输出原来的dy &#125; printf("\n"); cblas_daxpy(n, da, dx,incx, dy, incy); //运行daxpy程序 // cblas_dcopy(n, dx,incx, dy, incy); //运行dcopy程序 for(i=0;i&lt;n;i++)&#123; printf("%f ",dy[i]); //输出计算后的dy &#125; printf("\n"); return 0; &#125; 运行以下命令，生成a.out可执行文件1gcc c.c -I /opt/OpenBLAS/include/ -L/opt/OpenBLAS/lib -lopenblas 输入1./a.out 输出0.000000 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.00000090.000000 81.000000 72.000000 63.000000 54.000000 45.000000 36.000000 27.000000 18.000000 9.000000 安装成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装hexo]]></title>
    <url>%2F2018%2F03%2F11%2FUbuntu-Hexo%2F</url>
    <content type="text"><![CDATA[在Ubuntu16.04中安装hexo出现一系列的问题，总结一下安装hexo的步骤; 首先安装noejs，Ubuntu源中的nodejs时旧版本，所以需要在安装后更新nodejs; 123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm 更换成淘宝的镜像，否则非常慢1sudo npm config set registry https://registry.npm.taobao.org 可以通过 sudo npm config list 查看是否生效 安装更新版本的工具N1sudo npm install n -g 更新版本1sudo n stable 可以看到有 installed：版号，说明更新成功 安装hexo1sudo npm install -g hexo]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ssr服务器]]></title>
    <url>%2F2017%2F10%2F13%2Fssr%2F</url>
    <content type="text"><![CDATA[ssr 服务器配置 wget -N –no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh wget -N –no-check-certificate https://freed.ga/kernel/ruisu.sh &amp;&amp; bash ruisu.sh wget -N –no-check-certificate https://github.com/91yun/serverspeeder/raw/master/serverspeeder.sh &amp;&amp; bash serverspeeder.sh 备用wget -N –no-check-certificate https://raw.githubusercontent.com/91yun/serverspeeder/master/serverspeeder-all.sh &amp;&amp; bash serverspeeder-all.sh]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis中动态SQL的用法]]></title>
    <url>%2F2017%2F08%2F06%2FMybatisTage%2F</url>
    <content type="text"><![CDATA[在访问数据库时，需要拼装SQL语句，在Mybatis中提供了对SQL的拼装，只有几个简单的元素：if、test、choose，when，otherwise、where、set、trim、foreach、bind。用法都十分简单，总结以下基本的用法。首先准备一实体类1234567891011public class User &#123; private int id; private String name; private int sex; //省略掉构造方法和setter、getter方法&#125; if、test元素if 元素是最常用的判断语句，相当于java中的if语句。test元素用于条件判断的语句中，它的作用相当于判断真假。 常常与if联合使用。 以按姓名查询的例子来说明if和test的用法1234567&lt;select id="getUser" parameterType="string" resultType="com.yao.beans.User"&gt; select * from user where 1=1 &lt;if test="name != null and name != ''"&gt; and name = #&#123;name&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwose元素choose、when、otherwose是一个组合的元素，相当于java语句中的switch…case…default语句。 以按对象来查询的例子来说明choose、when、otherwose的用法1234567891011121314&lt;select id="getUserByChose" parameterType="com.yao.beans.User" resultType="com.yao.beans.User"&gt; select * from user where 1=1 &lt;choose&gt; &lt;when test="id !=null and id != ''"&gt; and id =#&#123;id&#125; &lt;/when&gt; &lt;when test=" name != null and name != ''"&gt; and name = #&#123;name&#125; &lt;/when&gt; &lt;otherwise&gt; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; where、set元素在前面的元素中查询时要加入1=1否则可能会出现语法错误，Mybatis提供了where标签来处理SQL语句 以按姓名查询为例子来说明where的用法123456789&lt;select id="getUserByWhere" parameterType="string" resultType="com.yao.beans.User"&gt; select * from user &lt;where&gt; &lt;if test="name != null and name != ''"&gt; and name = #&#123;name&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; where元素会判断SQL语句是不是要删去and或者or。 set元素用于更新操作。12345678910&lt;update id="updateBySet" parameterType="com.yao.beans.User"&gt; update user &lt;set&gt; &lt;if test="name != null and name != ''"&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; set元素在遇到,时会自动判断是不是在最后，需不需要删去。 trim元素有时候需要处理一些特殊的SQL语句，trim可以帮助处理一些不规则的语法。trim元素有点类似于replace。trim有四个属性 prefix：前缀覆盖并增加其内容。也就是给中的sql语句加上前缀； suffix：后缀覆盖并增加其内容。给包裹的sql语句加上后缀； prefixOverrides：前缀判断的条件。取消指定的前缀，如where； suffixOverrides：后缀判断的条件。取消指定的后缀，如and | or.，逗号等。 以插入一条数据来说明trim的用法123456789101112131415161718192021&lt;insert id="insertByTrim" parameterType="com.yao.beans.User"&gt; insert user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="name != null and name !=''"&gt; name, &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; sex, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides=","&gt; &lt;if test="name != null and name !=''"&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; #&#123;sex&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; trim处理完后相当于insert user (name ,sex) valuse( #{name},#{sex} ) foreach元素foreach元素是一个循环语句，它的作用是遍历集合，而且能够很好的支持数组和List、Set接口的集合。 以获取sex为1和0的例子来说明foreach的用法123456&lt;select id="findUserByForeach" resultType="com.yao.beans.User"&gt; select * from user where sex in &lt;foreach collection="sexList" item="sex" index="index" open="(" separator="," close=")"&gt; #&#123;sex&#125; &lt;/foreach&gt; &lt;/select&gt; collection 是传递进来的参数名称，可以是数组、List、Set等集合 item 当前元素 index 当前元素在集合的位置下标 open 以什么符号开始 separator 元素之间的分隔符 close 以什么时候结束 bind元素bind可以通过OGNL表达式去自定义一个上下文变量方便使用。 比如进行模糊查询12345&lt;select id="findUserByBind" resultType="com.yao.beans.User"&gt; &lt;bind name="patten" value="'%'+ _parameter+'%'"/&gt; select * from user where name like #&#123;patten&#125;&lt;/select&gt; _parameter是传进来的参数，跟通配符连接后赋值给patten。 bind可以定义多个对象。]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中CommandLineRunner和AplicationRunner]]></title>
    <url>%2F2017%2F08%2F04%2FCommandLine%2F</url>
    <content type="text"><![CDATA[在SpringBoot开发项目的时候，有时需要在Spring容器启动的时候执行一系列操作。在SpringBoot中提供了两个接口来实现这样的需求。 这两个接口为：CommandLineRunner和ApplicationRunner 这两个都有run方法，但是CommandLineRunner的参数为String数组，ApplicationRunner为ApplicationArguments。 CommandLineRunnerde实现123456789101112131415import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.CommandLineRunner;import org.springframework.stereotype.Component;@Componentpublic class MyStartUpCommandLineRunner implements CommandLineRunner &#123; private Logger logger =LoggerFactory.getLogger(MyStartUpCommandLineRunner.class); @Override public void run(String... strings) throws Exception &#123; logger.info("------&gt;MyStartUpCommandLineRunner&lt;-----"); &#125;&#125; ApplicationRunner的实现 1234567891011121314151617import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;@Componentpublic class MYStartUpApplicationRunner implements ApplicationRunner &#123; private Logger logger = LoggerFactory.getLogger(MYStartUpApplicationRunner.class); @Override public void run(ApplicationArguments applicationArguments) throws Exception &#123; logger.info("------&gt;MYStartUpApplicationRunner&lt;------"); &#125;&#125; 两个接口可以同时在一个项目中使用，存在多个的时候可以用@Order()注解来定义优先级。]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
