<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Ubuntu16.04下源码安装go1.10.1编译器]]></title>
    <url>%2F2018%2F04%2F12%2Fgo%2F</url>
    <content type="text"><![CDATA[Ubuntu下直接安装go1.10.1版本的go语言编译器需要依赖go1.4版本。所以在安装1.4版本以上的时候，需要安装1.4版本。 设置环境变量1sudo vim /etc/profile 在结尾处添加123export GOROOT=$HOME/goexport PATH=$PATH:$GOROOT/binexport GOPATH=$HOME/Applications/Go 使配置文件生效1source /etc/profile 安装C 工具1sudo apt-get install bison ed gawk gcc libc6-dev make 安装1.4下载地址 https://golang.org/dl/(需要翻墙)如果需要安装1.4以上的版本，需要把1.4版本一起下载。1tar -zxvf go1.4.linux-amd64.tar.gz 将文件移到/home/xxx,xxx为计算机名，并将文件名改为go1.4。如果已经在该目录下，则只把文件名改为go1.4即可。1mv go /home/xxx/go1.4 安装1.4编译器12cd go1.4/src/sudo CGO_ENABLED=0 ./make.bash 安装1.10.1解压1.10.1版本12tar -zxvf go1.10.linux-amd64.tar.gzmv go /home/xxx # xxx为计算机名 安装1.10.1 12cd /home/xxx/go/src./all.bash 安装成功如下图所示 测试在完成安装后可输入go env，如果显示类似以下内容，则表示成功1234567891011121314151617181920212223GOARCH=&quot;amd64&quot;GOBIN=&quot;&quot;GOCACHE=&quot;/home/yao/.cache/go-build&quot;GOEXE=&quot;&quot;GOHOSTARCH=&quot;amd64&quot;GOHOSTOS=&quot;linux&quot;GOOS=&quot;linux&quot;GOPATH=&quot;/home/yao/Applications/Go&quot;GORACE=&quot;&quot;GOROOT=&quot;/home/yao/go&quot;GOTMPDIR=&quot;&quot;GOTOOLDIR=&quot;/home/yao/go/pkg/tool/linux_amd64&quot;GCCGO=&quot;gccgo&quot;CC=&quot;gcc&quot;CXX=&quot;g++&quot;CGO_ENABLED=&quot;1&quot;CGO_CFLAGS=&quot;-g -O2&quot;CGO_CPPFLAGS=&quot;&quot;CGO_CXXFLAGS=&quot;-g -O2&quot;CGO_FFLAGS=&quot;-g -O2&quot;CGO_LDFLAGS=&quot;-g -O2&quot;PKG_CONFIG=&quot;pkg-config&quot;GOGCCFLAGS=&quot;-fPIC -m64 -pthread -fmessage-length=0 -fdebug-prefix-map=/tmp/go-build612857100=/tmp/go-build -gno-record-gcc-switches&quot; 如果没有，也可能是环境变量没有生效，重启一下电脑试试 代码测试新建一个hello.go文件，输入以下内容12345package mainfunc main() &#123; println("Hello", "world")&#125; 运行1go run hello.go 会输出Hello world]]></content>
      <tags>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建SpringBoot多模块项目]]></title>
    <url>%2F2018%2F03%2F25%2FSpringBootModule%2F</url>
    <content type="text"><![CDATA[今天搭建SpringBoot多模块项目，总是出现Unregistering JMX-exposed beans on shutdown，找了半天，才发现是jar包问题。 总结一下搭建SpringBoot多模块项目的步骤： 搭建项目架构1、创建一个maven空项目，并删掉src文件，如下图： 2、新建一个module，如下图 3、选择空maven项目，点击next，输入模块名，如下图： 4、一直默认下去，最后项目架构类似下图： 5、其他模块创建类似 配置文件1、在父工程的pom中配置如下： 12345678910111213141516171819202122232425 &lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--基本信息--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;!--项目信息--&gt; &lt;groupId&gt;com.yao&lt;/groupId&gt; &lt;artifactId&gt;BootModule&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--模块信息--&gt; &lt;modules&gt; &lt;module&gt;module_web&lt;/module&gt; &lt;/modules&gt; &lt;!--SpringBoot 的继承信息--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.0.0.RELEASE&lt;/version&gt; &lt;/parent&gt;&lt;/project&gt; 2、在moduel_web的pom文件配置123456789101112131415161718192021222324252627282930313233343536&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"&gt; &lt;!--继承的醒目说明--&gt; &lt;parent&gt; &lt;artifactId&gt;BootModule&lt;/artifactId&gt; &lt;groupId&gt;com.yao&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;!--项目说明--&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;module_web&lt;/artifactId&gt; &lt;!--具体相关的依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.yao&lt;/groupId&gt; &lt;artifactId&gt;module_service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 3、创建启动类和application.yml配置文件，结构如下图所示： 4、编写启动类123456789import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpirngMain &#123; public static void main(String[] args) &#123; SpringApplication.run(SpirngMain.class,args); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring boot使用拦截器]]></title>
    <url>%2F2018%2F03%2F24%2FspingbootInteceptor%2F</url>
    <content type="text"><![CDATA[在springboot web开发中经常需要拦截器，创建拦截器的步骤： 实现HandlerInterceptor接口，重写接口中的三个方法：12345678910111213141516171819202122232425262728293031import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class InterceptorConfig implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(InterceptorConfig.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.info("-------&gt;在controller执行之前执行&lt;-------"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.info("-------&gt;在controller执行之后，页面渲染之前执行&lt;-------"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.info("-------&gt;页面渲染之后，多用于资源清理操作&lt;-------"); &#125;&#125; 注册拦截器 12345678910import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;public class WebAppConfig extends WebMvcConfigurerAdapter &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new InterceptorConfig()).addPathPatterns("/*"); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MKL]]></title>
    <url>%2F2018%2F03%2F14%2FMKL%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04安装MKL：下载 https://software.intel.com/en-us/mkl 解压进入解压文件，执行：1./install.sh 在 /etc/ld.so.conf.d 下创建名为 intel-mkl.conf 的文件，内容为12/opt/intel/mkl/lib/intel64 /opt/intel/lib/intel64 执行123ldconfig -v /opt/intel/mkl/bin/mklvars.sh intel64 ilp64 编译：以编译官方文档上的 dgemm_example.c 为例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#define min(x,y) (((x) &lt; (y)) ? (x) : (y)) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "mkl.h" int main() &#123; double *A, *B, *C; int m, n, p, i, j; double alpha, beta; printf ("\n This example computes real matrix C=alpha*A*B+beta*C using \n" " Intel(R) MKL function dgemm, where A, B, and C are matrices and \n" " alpha and beta are double precision scalars\n\n"); m = 2000, p = 200, n = 1000; printf (" Initializing data for matrix multiplication C=A*B for matrix \n" " A(%ix%i) and matrix B(%ix%i)\n\n", m, p, p, n); alpha = 1.0; beta = 0.0; printf (" Allocating memory for matrices aligned on 64-byte boundary for better \n" " performance \n\n"); A = (double *)mkl_malloc( m*p*sizeof( double ), 64 ); B = (double *)mkl_malloc( p*n*sizeof( double ), 64 ); C = (double *)mkl_malloc( m*n*sizeof( double ), 64 ); if (A == NULL || B == NULL || C == NULL) &#123; printf( "\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"); mkl_free(A); mkl_free(B); mkl_free(C); return 1; &#125; printf (" Intializing matrix data \n\n"); for (i = 0; i &lt; (m*p); i++) &#123; A[i] = (double)(i+1); &#125; for (i = 0; i &lt; (p*n); i++) &#123; B[i] = (double)(-i-1); &#125; for (i = 0; i &lt; (m*n); i++) &#123; C[i] = 0.0; &#125; printf (" Computing matrix product using Intel(R) MKL dgemm function via CBLAS interface \n\n"); cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, m, n, p, alpha, A, p, B, n, beta, C, n); printf ("\n Computations completed.\n\n"); printf (" Top left corner of matrix A: \n"); for (i=0; i&lt;min(m,6); i++) &#123; for (j=0; j&lt;min(p,6); j++) &#123; printf ("%12.0f", A[j+i*p]); &#125; printf ("\n"); &#125; printf ("\n Top left corner of matrix B: \n"); for (i=0; i&lt;min(p,6); i++) &#123; for (j=0; j&lt;min(n,6); j++) &#123; printf ("%12.0f", B[j+i*n]); &#125; printf ("\n"); &#125; printf ("\n Top left corner of matrix C: \n"); for (i=0; i&lt;min(m,6); i++) &#123; for (j=0; j&lt;min(n,6); j++) &#123; printf ("%12.5G", C[j+i*n]); &#125; printf ("\n"); &#125; printf ("\n Deallocating memory \n\n"); mkl_free(A); mkl_free(B); mkl_free(C); printf (" Example completed. \n\n"); return 0; &#125; 执行123. /opt/intel/bin/compilervars.sh intel64gcc dgemm_example.c -lmkl_rt]]></content>
  </entry>
  <entry>
    <title><![CDATA[Springboot中AOP的使用]]></title>
    <url>%2F2018%2F03%2F14%2FSpringboot-AOP%2F</url>
    <content type="text"><![CDATA[AOP是spring的两个主要模块功能之一，总结一下aop的基本用法 切面类组成首先需要在类中用@Aspect，说明这个类时切面类，这个类主要由两个部分组成：@Pointcut和Advice @Pointcut@Pointcut是一个注解，标注在类中的方法上，主要的作用是说明要处理那些类和那些方法。 @Pointcut 里的参数式一个表达式，包括指示器、通配符和运算符。 指示器按功能主要包括5类： 匹配方法：execution() 匹配注解：@target() @arges() @within() @annotation() 匹配包或类型：within() 匹配对象：this() bean() target() 匹配参数：arges() 注意！！ 只有匹配注解的前边有@符号 通配符主要包含3种： *：任意数量的字符 +：指定类及其子类 ..：任意数的子包或参数 运算符也主要包括3种： &amp;&amp;：与 ||：或 ！：非 AdviceAdvice说明了要执行的时机，主要是标注的类的方法上。 Advice主要有5种注解： @Before：前置通知 @After： 后置通知，方法执行完之后 @AfterReturning： 返回通知，成功执行之后 @AfterThrowing：异常通知，抛出异常之后 @Around：环绕通知 用法@Pointcut用法 在@Pointcut中execution()的应用最广，所以主要以execution()为例说明@Pointcut的用法 execution()的语法为： execution(方法修饰符(可选) 返回类型 方法名 参数 异常模式(可选)) 12@Pointcut("execution(public * com.example.aopdemo.Controller.*.*(..))")public void excudeService()&#123;&#125; 这个java代码中： 第一个* 号说明返回值为任意类型 第二个*号说明是任意类 第三个* 号说明的是任意方法 .. 说明参数为任意个所以整个 @Pointcut说明处理的是com.example.aopdemo.Controller包下所有的类以及类中所有的方法，方法参数不限的方法。 Advice用法 Advice的用法大同小异，主要的差别是执行的时机，所以，主要以@Before为例说明用法 12345678@Before("excudeService()")public void before(JoinPoint joinPoint)&#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method=methodSignature.getMethod(); logger.info("-----------"+method.getName()); logger.info("---------before---------");&#125; 这个before方法说明在excudeService()这个@Pointcut处理的范围之内，所有方法运行之前先运行before函数。 完整Aspect类例子的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.lang.reflect.Method;@Aspect@Componentpublic class AopConfig &#123; Logger logger = LoggerFactory.getLogger(AopConfig.class); @Pointcut("execution(public * com.example.aopdemo.Controller.*.*(..))") public void excudeService()&#123;&#125; @Pointcut("execution(* *..find*(String)) &amp;&amp; within(com.example..*) ") public void matchLongArg()&#123;&#125; @Before("excudeService()") public void before(JoinPoint joinPoint)&#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method=methodSignature.getMethod(); logger.info("-----------"+method.getName()); logger.info("---------before---------"); &#125; @After("excudeService()") public void after(JoinPoint joinPoint)&#123; Object [] args = joinPoint.getArgs(); for (int i = 0; i &lt; args.length; i++) &#123; logger.info(String.valueOf(args[i])); &#125; logger.info("---------after---------"); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装openBLAS]]></title>
    <url>%2F2018%2F03%2F13%2Finstall-openBLAS%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04 安装OpenBLAS步骤 12345git clone git://github.com/xianyi/OpenBLAScd OpenBLASsudo apt-get install gfortransudo make FC=gfortransudo make install 最后安装在/opt下 然后执行以下命令：1ln -s /opt/OpenBLAS/lib/libopenblas.so.0 /usr/lib/libopenblas.so.0 建立一个c.c文件，输入以下内容123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "cblas.h"int main()&#123; int n; /*! array size */ double da; /*! double constant */ double *dx; /*! input double array */ int incx; /*! input stride */ double *dy; /*! output double array */ int incy; /*! output stride */ int i; n = 10; da = 10; dx = (double*)malloc(sizeof(double)*n); incx = 1; dy = (double*)malloc(sizeof(double)*n); incy = 1; for(i=0;i&lt;n;i++)&#123; dx[i] = 9-i; dy[i] = i; printf("%f ",dy[i]); //输出原来的dy &#125; printf("\n"); cblas_daxpy(n, da, dx,incx, dy, incy); //运行daxpy程序 // cblas_dcopy(n, dx,incx, dy, incy); //运行dcopy程序 for(i=0;i&lt;n;i++)&#123; printf("%f ",dy[i]); //输出计算后的dy &#125; printf("\n"); return 0; &#125; 运行以下命令，生成a.out可执行文件1gcc c.c -I /opt/OpenBLAS/include/ -L/opt/OpenBLAS/lib -lopenblas 输入1./a.out 输出0.000000 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.00000090.000000 81.000000 72.000000 63.000000 54.000000 45.000000 36.000000 27.000000 18.000000 9.000000 安装成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装hexo]]></title>
    <url>%2F2018%2F03%2F11%2FUbuntu-Hexo%2F</url>
    <content type="text"><![CDATA[在Ubuntu16.04中安装hexo出现一系列的问题，总结一下安装hexo的步骤; 首先安装noejs，Ubuntu源中的nodejs时旧版本，所以需要在安装后更新nodejs; 123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm 更换成淘宝的镜像，否则非常慢1sudo npm config set registry https://registry.npm.taobao.org 可以通过 sudo npm config list 查看是否生效 安装更新版本的工具N1sudo npm install n -g 更新版本1sudo n stable 可以看到有 installed：版号，说明更新成功 安装hexo1sudo npm install -g hexo]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM内存模型]]></title>
    <url>%2F2017%2F09%2F02%2FJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JVM内存模型Java虚拟机(Java Virtual Machine=JVM)的内存空间分为五个部分，分别是： 程序计数器 Java虚拟机栈 本地方法栈 堆 方法区。 下面对这五个区域展开深入的介绍。 1. 程序计数器1.1. 什么是程序计数器？程序计数器是一块较小的内存空间，可以把它看作当前线程正在执行的字节码的行号指示器。也就是说，程序计数器里面记录的是当前线程正在执行的那一条字节码指令的地址。注：但是，如果当前线程正在执行的是一个本地方法，那么此时程序计数器为空。 1.2. 程序计数器的作用程序计数器有两个作用： 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。 1.3. 程序计数器的特点是一块较小的存储空间 线程私有。每条线程都有一个程序计数器。 是唯一一个不会出现OutOfMemoryError的内存区域。 生命周期随着线程的创建而创建，随着线程的结束而死亡。 2. Java虚拟机栈(JVM Stack)2.1. 什么是Java虚拟机栈？Java虚拟机栈是描述Java方法运行过程的内存模型。Java虚拟机栈会为每一个即将运行的Java方法创建一块叫做“栈帧”的区域，这块区域用于存储该方法在运行过程中所需要的一些信息，这些信息包括： 局部变量表 存放基本数据类型变量、引用类型的变量、returnAddress类型的变量。 操作数栈 动态链接 方法出口信息 等 当一个方法即将被运行时，Java虚拟机栈首先会在Java虚拟机栈中为该方法创建一块“栈帧”，栈帧中包含局部变量表、操作数栈、动态链接、方法出口信息等。当方法在运行过程中需要创建局部变量时，就将局部变量的值存入栈帧的局部变量表中。当这个方法执行完毕后，这个方法所对应的栈帧将会出栈，并释放内存空间。 注意：人们常说，Java的内存空间分为“栈”和“堆”，栈中存放局部变量，堆中存放对象。这句话不完全正确！这里的“堆”可以这么理解，但这里的“栈”只代表了Java虚拟机栈中的局部变量表部分。真正的Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。 2.2. Java虚拟机栈的特点局部变量表的创建是在方法被执行的时候，随着栈帧的创建而创建。而且，局部变量表的大小在编译时期就确定下来了，在创建的时候只需分配事先规定好的大小即可。此外，在方法运行的过程中局部变量表的大小是不会发生改变的。 Java虚拟机栈会出现两种异常：StackOverFlowError和OutOfMemoryError。 a) StackOverFlowError： 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。 b) OutOfMemoryError： 若Java虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。 Java虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。 注：StackOverFlowError和OutOfMemoryError的异同？StackOverFlowError表示当前线程申请的栈超过了事先定好的栈的最大深度，但内存空间可能还有很多。而OutOfMemoryError是指当线程申请栈时发现栈已经满了，而且内存也全都用光了。 3. 本地方法栈3.1. 什么是本地方法栈？本地方法栈和Java虚拟机栈实现的功能类似，只不过本地方法区是本地方法运行的内存模型。 本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。 方法执行完毕后相应的栈帧也会出栈并释放内存空间。 也会抛出StackOverFlowError和OutOfMemoryError异常。 4. 堆4.1. 什么是堆？堆是用来存放对象的内存空间。几乎所有的对象都存储在堆中。 4.2. 堆的特点线程共享 整个Java虚拟机只有一个堆，所有的线程都访问同一个堆。而程序计数器、Java虚拟机栈、本地方法栈都是一个线程对应一个的。 在虚拟机启动时创建 垃圾回收的主要场所。 可以进一步细分为：新生代、老年代。 新生代又可被分为：Eden、From Survior、To Survior。 不同的区域存放具有不同生命周期的对象。这样可以根据不同的区域使用不同的垃圾回收算法，从而更具有针对性，从而更高效。 堆的大小既可以固定也可以扩展，但主流的虚拟机堆的大小是可扩展的，因此当线程请求分配内存，但堆已满，且内存已满无法再扩展时，就抛出OutOfMemoryError。 5. 方法区5.1. 什么是方法区？Java虚拟机规范中定义方法区是堆的一个逻辑部分。方法区中存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等。 5.2. 方法区的特点线程共享 方法区是堆的一个逻辑部分，因此和堆一样，都是线程共享的。整个虚拟机中只有一个方法区。 永久代 方法区中的信息一般需要长期存在，而且它又是堆的逻辑分区，因此用堆的划分方法，我们把方法区称为老年代。 内存回收效率低 方法区中的信息一般需要长期存在，回收一遍内存之后可能只有少量信息无效。 对方法区的内存回收的主要目标是：对常量池的回收 和 对类型的卸载。 Java虚拟机规范对方法区的要求比较宽松。 和堆一样，允许固定大小，也允许可扩展的大小，还允许不实现垃圾回收。 5.3. 什么是运行时常量池？方法区中存放三种数据：类信息、常量、静态变量、即时编译器编译后的代码。其中常量存储在运行时常量池中。 我们一般在一个类中通过public static final来声明一个常量。这个类被编译后便生成Class文件，这个类的所有信息都存储在这个class文件中。 当这个类被Java虚拟机加载后，class文件中的常量就存放在方法区的运行时常量池中。而且在运行期间，可以向常量池中添加新的常量。如：String类的intern()方法就能在运行期间向常量池中添加字符串常量。 当运行时常量池中的某些常量没有被对象引用，同时也没有被变量引用，那么就需要垃圾收集器回收。 6. 直接内存直接内存是除Java虚拟机之外的内存，但也有可能被Java使用。 在NIO中引入了一种基于通道和缓冲的IO方式。它可以通过调用本地方法直接分配Java虚拟机之外的内存，然后通过一个存储在Java堆中的DirectByteBuffer对象直接操作该内存，而无需先将外面内存中的数据复制到堆中再操作，从而提升了数据操作的效率。 直接内存的大小不受Java虚拟机控制，但既然是内存，当内存不足时就会抛出OOM异常。 综上所述 Java虚拟机的内存模型中一共有两个“栈”，分别是：Java虚拟机栈和本地方法栈。 两个“栈”的功能类似，都是方法运行过程的内存模型。并且两个“栈”内部构造相同，都是线程私有。 只不过Java虚拟机栈描述的是Java方法运行过程的内存模型，而本地方法栈是描述Java本地方法运行过程的内存模型。 Java虚拟机的内存模型中一共有两个“堆”，一个是原本的堆，一个是方法区。方法区本质上是属于堆的一个逻辑部分。堆中存放对象，方法区中存放类信息、常量、静态变量、即时编译器编译的代码。 堆是Java虚拟机中最大的一块内存区域，也是垃圾收集器主要的工作区域。 程序计数器、Java虚拟机栈、本地方法栈是线程私有的，即每个线程都拥有各自的程序计数器、Java虚拟机栈、本地方法区。并且他们的生命周期和所属的线程一样。 而堆、方法区是线程共享的，在Java虚拟机中只有一个堆、一个方法栈。并在JVM启动的时候就创建，JVM停止才销毁。 转载自：https://blog.csdn.net/u010425776/article/details/51170118]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis中动态SQL的用法]]></title>
    <url>%2F2017%2F08%2F06%2FMybatisTage%2F</url>
    <content type="text"><![CDATA[在访问数据库时，需要拼装SQL语句，在Mybatis中提供了对SQL的拼装，只有几个简单的元素：if、test、choose，when，otherwise、where、set、trim、foreach、bind。用法都十分简单，总结以下基本的用法。首先准备一实体类1234567891011public class User &#123; private int id; private String name; private int sex; //省略掉构造方法和setter、getter方法&#125; if、test元素if 元素是最常用的判断语句，相当于java中的if语句。test元素用于条件判断的语句中，它的作用相当于判断真假。 常常与if联合使用。 以按姓名查询的例子来说明if和test的用法1234567&lt;select id="getUser" parameterType="string" resultType="com.yao.beans.User"&gt; select * from user where 1=1 &lt;if test="name != null and name != ''"&gt; and name = #&#123;name&#125; &lt;/if&gt;&lt;/select&gt; choose、when、otherwose元素choose、when、otherwose是一个组合的元素，相当于java语句中的switch…case…default语句。 以按对象来查询的例子来说明choose、when、otherwose的用法1234567891011121314&lt;select id="getUserByChose" parameterType="com.yao.beans.User" resultType="com.yao.beans.User"&gt; select * from user where 1=1 &lt;choose&gt; &lt;when test="id !=null and id != ''"&gt; and id =#&#123;id&#125; &lt;/when&gt; &lt;when test=" name != null and name != ''"&gt; and name = #&#123;name&#125; &lt;/when&gt; &lt;otherwise&gt; &lt;/otherwise&gt; &lt;/choose&gt; &lt;/select&gt; where、set元素在前面的元素中查询时要加入1=1否则可能会出现语法错误，Mybatis提供了where标签来处理SQL语句 以按姓名查询为例子来说明where的用法123456789&lt;select id="getUserByWhere" parameterType="string" resultType="com.yao.beans.User"&gt; select * from user &lt;where&gt; &lt;if test="name != null and name != ''"&gt; and name = #&#123;name&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; where元素会判断SQL语句是不是要删去and或者or。 set元素用于更新操作。12345678910&lt;update id="updateBySet" parameterType="com.yao.beans.User"&gt; update user &lt;set&gt; &lt;if test="name != null and name != ''"&gt; name = #&#123;name&#125;, &lt;/if&gt; &lt;/set&gt; where id = #&#123;id&#125; &lt;/update&gt; set元素在遇到,时会自动判断是不是在最后，需不需要删去。 trim元素有时候需要处理一些特殊的SQL语句，trim可以帮助处理一些不规则的语法。trim元素有点类似于replace。trim有四个属性 prefix：前缀覆盖并增加其内容。也就是给中的sql语句加上前缀； suffix：后缀覆盖并增加其内容。给包裹的sql语句加上后缀； prefixOverrides：前缀判断的条件。取消指定的前缀，如where； suffixOverrides：后缀判断的条件。取消指定的后缀，如and | or.，逗号等。 以插入一条数据来说明trim的用法123456789101112131415161718192021&lt;insert id="insertByTrim" parameterType="com.yao.beans.User"&gt; insert user &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;if test="name != null and name !=''"&gt; name, &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; sex, &lt;/if&gt; &lt;/trim&gt; &lt;trim prefix="values (" suffix=")" suffixOverrides=","&gt; &lt;if test="name != null and name !=''"&gt; #&#123;name&#125;, &lt;/if&gt; &lt;if test="sex != null and sex != ''"&gt; #&#123;sex&#125;, &lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; trim处理完后相当于insert user (name ,sex) valuse( #{name},#{sex} ) foreach元素foreach元素是一个循环语句，它的作用是遍历集合，而且能够很好的支持数组和List、Set接口的集合。 以获取sex为1和0的例子来说明foreach的用法123456&lt;select id="findUserByForeach" resultType="com.yao.beans.User"&gt; select * from user where sex in &lt;foreach collection="sexList" item="sex" index="index" open="(" separator="," close=")"&gt; #&#123;sex&#125; &lt;/foreach&gt; &lt;/select&gt; collection 是传递进来的参数名称，可以是数组、List、Set等集合 item 当前元素 index 当前元素在集合的位置下标 open 以什么符号开始 separator 元素之间的分隔符 close 以什么时候结束 bind元素bind可以通过OGNL表达式去自定义一个上下文变量方便使用。 比如进行模糊查询12345&lt;select id="findUserByBind" resultType="com.yao.beans.User"&gt; &lt;bind name="patten" value="'%'+ _parameter+'%'"/&gt; select * from user where name like #&#123;patten&#125;&lt;/select&gt; _parameter是传进来的参数，跟通配符连接后赋值给patten。 bind可以定义多个对象。]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot中CommandLineRunner和AplicationRunner]]></title>
    <url>%2F2017%2F08%2F04%2FCommandLine%2F</url>
    <content type="text"><![CDATA[在SpringBoot开发项目的时候，有时需要在Spring容器启动的时候执行一系列操作。在SpringBoot中提供了两个接口来实现这样的需求。 这两个接口为：CommandLineRunner和ApplicationRunner 这两个都有run方法，但是CommandLineRunner的参数为String数组，ApplicationRunner为ApplicationArguments。 CommandLineRunnerde实现123456789101112131415import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.CommandLineRunner;import org.springframework.stereotype.Component;@Componentpublic class MyStartUpCommandLineRunner implements CommandLineRunner &#123; private Logger logger =LoggerFactory.getLogger(MyStartUpCommandLineRunner.class); @Override public void run(String... strings) throws Exception &#123; logger.info("------&gt;MyStartUpCommandLineRunner&lt;-----"); &#125;&#125; ApplicationRunner的实现 1234567891011121314151617import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.boot.ApplicationArguments;import org.springframework.boot.ApplicationRunner;import org.springframework.stereotype.Component;@Componentpublic class MYStartUpApplicationRunner implements ApplicationRunner &#123; private Logger logger = LoggerFactory.getLogger(MYStartUpApplicationRunner.class); @Override public void run(ApplicationArguments applicationArguments) throws Exception &#123; logger.info("------&gt;MYStartUpApplicationRunner&lt;------"); &#125;&#125; 两个接口可以同时在一个项目中使用，存在多个的时候可以用@Order()注解来定义优先级。]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F03%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
