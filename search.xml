<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Spring boot使用拦截器]]></title>
    <url>%2F2018%2F03%2F24%2FspingbootInteceptor%2F</url>
    <content type="text"><![CDATA[在springboot web开发中经常需要拦截器，创建拦截器的步骤： 实现HandlerInterceptor接口，重写接口中的三个方法：12345678910111213141516171819202122232425262728293031import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;public class InterceptorConfig implements HandlerInterceptor &#123; private static final Logger logger = LoggerFactory.getLogger(InterceptorConfig.class); @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) &#123; logger.info("-------&gt;在controller执行之前执行&lt;-------"); return true; &#125; @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) &#123; logger.info("-------&gt;在controller执行之后，页面渲染之前执行&lt;-------"); &#125; @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) &#123; logger.info("-------&gt;页面渲染之后，多用于资源清理操作&lt;-------"); &#125;&#125; 注册拦截器 12345678910import org.springframework.web.servlet.config.annotation.InterceptorRegistry;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;public class WebAppConfig extends WebMvcConfigurerAdapter &#123; @Override public void addInterceptors(InterceptorRegistry registry) &#123; registry.addInterceptor(new InterceptorConfig()).addPathPatterns("/*"); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MKL]]></title>
    <url>%2F2018%2F03%2F14%2FMKL%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04安装MKL：下载 https://software.intel.com/en-us/mkl 解压进入解压文件，执行：1./install.sh 在 /etc/ld.so.conf.d 下创建名为 intel-mkl.conf 的文件，内容为12/opt/intel/mkl/lib/intel64 /opt/intel/lib/intel64 执行123ldconfig -v /opt/intel/mkl/bin/mklvars.sh intel64 ilp64 编译：以编译官方文档上的 dgemm_example.c 为例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#define min(x,y) (((x) &lt; (y)) ? (x) : (y)) #include &lt;stdio.h&gt; #include &lt;stdlib.h&gt; #include "mkl.h" int main() &#123; double *A, *B, *C; int m, n, p, i, j; double alpha, beta; printf ("\n This example computes real matrix C=alpha*A*B+beta*C using \n" " Intel(R) MKL function dgemm, where A, B, and C are matrices and \n" " alpha and beta are double precision scalars\n\n"); m = 2000, p = 200, n = 1000; printf (" Initializing data for matrix multiplication C=A*B for matrix \n" " A(%ix%i) and matrix B(%ix%i)\n\n", m, p, p, n); alpha = 1.0; beta = 0.0; printf (" Allocating memory for matrices aligned on 64-byte boundary for better \n" " performance \n\n"); A = (double *)mkl_malloc( m*p*sizeof( double ), 64 ); B = (double *)mkl_malloc( p*n*sizeof( double ), 64 ); C = (double *)mkl_malloc( m*n*sizeof( double ), 64 ); if (A == NULL || B == NULL || C == NULL) &#123; printf( "\n ERROR: Can't allocate memory for matrices. Aborting... \n\n"); mkl_free(A); mkl_free(B); mkl_free(C); return 1; &#125; printf (" Intializing matrix data \n\n"); for (i = 0; i &lt; (m*p); i++) &#123; A[i] = (double)(i+1); &#125; for (i = 0; i &lt; (p*n); i++) &#123; B[i] = (double)(-i-1); &#125; for (i = 0; i &lt; (m*n); i++) &#123; C[i] = 0.0; &#125; printf (" Computing matrix product using Intel(R) MKL dgemm function via CBLAS interface \n\n"); cblas_dgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, m, n, p, alpha, A, p, B, n, beta, C, n); printf ("\n Computations completed.\n\n"); printf (" Top left corner of matrix A: \n"); for (i=0; i&lt;min(m,6); i++) &#123; for (j=0; j&lt;min(p,6); j++) &#123; printf ("%12.0f", A[j+i*p]); &#125; printf ("\n"); &#125; printf ("\n Top left corner of matrix B: \n"); for (i=0; i&lt;min(p,6); i++) &#123; for (j=0; j&lt;min(n,6); j++) &#123; printf ("%12.0f", B[j+i*n]); &#125; printf ("\n"); &#125; printf ("\n Top left corner of matrix C: \n"); for (i=0; i&lt;min(m,6); i++) &#123; for (j=0; j&lt;min(n,6); j++) &#123; printf ("%12.5G", C[j+i*n]); &#125; printf ("\n"); &#125; printf ("\n Deallocating memory \n\n"); mkl_free(A); mkl_free(B); mkl_free(C); printf (" Example completed. \n\n"); return 0; &#125; 执行123. /opt/intel/bin/compilervars.sh intel64gcc dgemm_example.c -lmkl_rt]]></content>
  </entry>
  <entry>
    <title><![CDATA[Springboot中AOP的使用]]></title>
    <url>%2F2018%2F03%2F14%2FSpringboot-AOP%2F</url>
    <content type="text"><![CDATA[AOP是spring的两个主要模块功能之一，总结一下aop的基本用法 切面类组成首先需要在类中用@Aspect，说明这个类时切面类，这个类主要由两个部分组成：@Pointcut和Advice @Pointcut@Pointcut是一个注解，标注在类中的方法上，主要的作用是说明要处理那些类和那些方法。 @Pointcut 里的参数式一个表达式，包括指示器、通配符和运算符。 指示器按功能主要包括5类： 匹配方法：execution() 匹配注解：@target() @arges() @within() @annotation() 匹配包或类型：within() 匹配对象：this() bean() target() 匹配参数：arges() 注意！！ 只有匹配注解的前边有@符号 通配符主要包含3种： *：任意数量的字符 +：指定类及其子类 ..：任意数的子包或参数 运算符也主要包括3种： &amp;&amp;：与 ||：或 ！：非 AdviceAdvice说明了要执行的时机，主要是标注的类的方法上。 Advice主要有5种注解： @Before：前置通知 @After： 后置通知，方法执行完之后 @AfterReturning： 返回通知，成功执行之后 @AfterThrowing：异常通知，抛出异常之后 @Around：环绕通知 用法@Pointcut用法 在@Pointcut中execution()的应用最广，所以主要以execution()为例说明@Pointcut的用法 execution()的语法为： execution(方法修饰符(可选) 返回类型 方法名 参数 异常模式(可选)) 12@Pointcut("execution(public * com.example.aopdemo.Controller.*.*(..))")public void excudeService()&#123;&#125; 这个java代码中： 第一个* 号说明返回值为任意类型 第二个*号说明是任意类 第三个* 号说明的是任意方法 .. 说明参数为任意个所以整个 @Pointcut说明处理的是com.example.aopdemo.Controller包下所有的类以及类中所有的方法，方法参数不限的方法。 Advice用法 Advice的用法大同小异，主要的差别是执行的时机，所以，主要以@Before为例说明用法 12345678@Before("excudeService()")public void before(JoinPoint joinPoint)&#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method=methodSignature.getMethod(); logger.info("-----------"+method.getName()); logger.info("---------before---------");&#125; 这个before方法说明在excudeService()这个@Pointcut处理的范围之内，所有方法运行之前先运行before函数。 完整Aspect类例子的代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import org.aspectj.lang.JoinPoint;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.aspectj.lang.reflect.MethodSignature;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.stereotype.Component;import java.lang.reflect.Method;@Aspect@Componentpublic class AopConfig &#123; Logger logger = LoggerFactory.getLogger(AopConfig.class); @Pointcut("execution(public * com.example.aopdemo.Controller.*.*(..))") public void excudeService()&#123;&#125; @Pointcut("execution(* *..find*(String)) &amp;&amp; within(com.example..*) ") public void matchLongArg()&#123;&#125; @Before("excudeService()") public void before(JoinPoint joinPoint)&#123; MethodSignature methodSignature = (MethodSignature) joinPoint.getSignature(); Method method=methodSignature.getMethod(); logger.info("-----------"+method.getName()); logger.info("---------before---------"); &#125; @After("excudeService()") public void after(JoinPoint joinPoint)&#123; Object [] args = joinPoint.getArgs(); for (int i = 0; i &lt; args.length; i++) &#123; logger.info(String.valueOf(args[i])); &#125; logger.info("---------after---------"); &#125;&#125;]]></content>
      <tags>
        <tag>springboot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装openBLAS]]></title>
    <url>%2F2018%2F03%2F13%2Finstall-openBLAS%2F</url>
    <content type="text"><![CDATA[Ubuntu 16.04 安装OpenBLAS步骤 12345git clone git://github.com/xianyi/OpenBLAScd OpenBLASsudo apt-get install gfortransudo make FC=gfortransudo make install 最后安装在/opt下 然后执行以下命令：1ln -s /opt/OpenBLAS/lib/libopenblas.so.0 /usr/lib/libopenblas.so.0 建立一个c.c文件，输入以下内容123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include "cblas.h"int main()&#123; int n; /*! array size */ double da; /*! double constant */ double *dx; /*! input double array */ int incx; /*! input stride */ double *dy; /*! output double array */ int incy; /*! output stride */ int i; n = 10; da = 10; dx = (double*)malloc(sizeof(double)*n); incx = 1; dy = (double*)malloc(sizeof(double)*n); incy = 1; for(i=0;i&lt;n;i++)&#123; dx[i] = 9-i; dy[i] = i; printf("%f ",dy[i]); //输出原来的dy &#125; printf("\n"); cblas_daxpy(n, da, dx,incx, dy, incy); //运行daxpy程序 // cblas_dcopy(n, dx,incx, dy, incy); //运行dcopy程序 for(i=0;i&lt;n;i++)&#123; printf("%f ",dy[i]); //输出计算后的dy &#125; printf("\n"); return 0; &#125; 运行以下命令，生成a.out可执行文件1gcc c.c -I /opt/OpenBLAS/include/ -L/opt/OpenBLAS/lib -lopenblas 输入1./a.out 输出0.000000 1.000000 2.000000 3.000000 4.000000 5.000000 6.000000 7.000000 8.000000 9.00000090.000000 81.000000 72.000000 63.000000 54.000000 45.000000 36.000000 27.000000 18.000000 9.000000 安装成功]]></content>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu16.04安装hexo]]></title>
    <url>%2F2018%2F03%2F11%2FUbuntu-Hexo%2F</url>
    <content type="text"><![CDATA[在Ubuntu16.04中安装hexo出现一系列的问题，总结一下安装hexo的步骤; 首先安装noejs，Ubuntu源中的nodejs时旧版本，所以需要在安装后更新nodejs; 123sudo apt-get install nodejssudo apt install nodejs-legacysudo apt install npm 更换成淘宝的镜像，否则非常慢1sudo npm config set registry https://registry.npm.taobao.org 可以通过 sudo npm config list 查看是否生效 安装更新版本的工具N1sudo npm install n -g 更新版本1sudo n stable 可以看到有 installed：版号，说明更新成功 安装hexo1sudo npm install -g hexo]]></content>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F03%2F08%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
